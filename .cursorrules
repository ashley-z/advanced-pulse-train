# Figma MCP Integration Project - Cursor Rules

## Project Overview
This is a Model Context Protocol (MCP) integration for Figma that allows AI assistants and tools to access Figma design files through a standardized interface.

## Architecture
- **MCP Server**: `figma-mcp-server.js` - Main server implementing the MCP protocol
- **MCP Client**: `client-example.js` - Example client demonstrating usage
- **API Integration**: Direct Figma API calls with proper authentication
- **ES Modules**: All files use modern ES module syntax

## Coding Standards

### JavaScript/Node.js
- Use ES modules (import/export) instead of CommonJS (require/module.exports)
- Use async/await for all asynchronous operations
- Implement proper error handling with try/catch blocks
- Use descriptive variable and function names
- Add JSDoc comments for complex functions
- Use const for immutable variables, let for mutable ones

### MCP Protocol Implementation
- Follow the Model Context Protocol specification strictly
- Implement proper request/response handling
- Use correct MCP message formats and types
- Handle errors gracefully and return appropriate error responses
- Maintain backward compatibility with MCP versions

### Figma API Integration
- Always use environment variables for sensitive data (tokens, keys)
- Implement proper rate limiting and error handling
- Use appropriate HTTP status codes and error messages
- Cache responses when appropriate to reduce API calls
- Validate all input parameters before making API calls

## File Structure
```
/
├── figma-mcp-server.js      # Main MCP server
├── client-example.js         # Example MCP client
├── test-*.js                # Test files
├── package.json             # Dependencies and scripts
├── .env                     # Environment variables (gitignored)
├── .cursorrules            # This file
└── README.md               # Documentation
```

## Security Guidelines
- Never commit `.env` files or sensitive tokens
- Use environment variables for all configuration
- Validate and sanitize all user inputs
- Implement proper authentication and authorization
- Log security-relevant events appropriately

## Testing Requirements
- Create test files for all major functionality
- Test both success and error scenarios
- Mock external API calls in unit tests
- Test MCP protocol compliance
- Verify Figma API integration works correctly

## Documentation Standards
- Keep README.md up to date with setup instructions
- Document all MCP tools and resources
- Include examples for common use cases
- Document error codes and troubleshooting steps
- Maintain API documentation for custom functions

## Development Workflow
1. Always test API changes with the test scripts
2. Verify MCP protocol compliance before committing
3. Update documentation when adding new features
4. Use semantic versioning for releases
5. Test with actual Figma files before deployment

## Common Patterns

### Error Handling
```javascript
try {
  const response = await axios.get(url, { headers });
  return response.data;
} catch (error) {
  console.error('API Error:', error.message);
  throw new Error(`Failed to fetch data: ${error.message}`);
}
```

### MCP Tool Implementation
```javascript
this.server.setRequestHandler('tools/call', async (request) => {
  const { name, arguments: args } = request.params;
  
  switch (name) {
    case 'tool_name':
      return await this.handleTool(args);
    default:
      throw new Error(`Unknown tool: ${name}`);
  }
});
```

### Environment Configuration
```javascript
import dotenv from 'dotenv';
dotenv.config();

const token = process.env.FIGMA_ACCESS_TOKEN;
if (!token) {
  throw new Error('FIGMA_ACCESS_TOKEN is required');
}
```

## Performance Considerations
- Implement caching for frequently accessed data
- Use connection pooling for HTTP requests
- Minimize API calls by batching requests
- Implement proper cleanup in MCP server shutdown
- Monitor memory usage and implement garbage collection

## Troubleshooting
- Check environment variables are set correctly
- Verify Figma API token has proper scopes
- Test MCP server connectivity
- Check network connectivity for API calls
- Review error logs for debugging

## Future Enhancements
- Add support for Figma plugins
- Implement real-time collaboration features
- Add support for Figma design systems
- Create webhook integrations
- Add support for multiple Figma accounts

## Advanced Pulse Train Validation and Mathematical Rules

### Core Mathematical Relationship
The pulse train system enforces the fundamental relationship:
```
Period = Pulse Width + Interval
```

This relationship is the cornerstone of all calculations and validations in the system.

### Pulse and Waveform Structure
- **One Pulse**: Consists of one ON segment (pulse width) + one OFF segment (interval)
- **Period**: One complete pulse cycle = Pulse Width + Interval
- **Waveform**: Consists of (pulse × pulse count) segments
- **Total Segments**: 2 × pulse count (each pulse has 2 segments)

### Parameter Locking System
The system implements an intelligent parameter locking mechanism where **exactly one parameter must always be locked**:

- **Period Locked**: When period is locked, changing pulse width automatically recalculates interval
- **Pulse Width Locked**: When pulse width is locked, changing period automatically recalculates interval  
- **Interval Locked**: When interval is locked, changing period automatically recalculates pulse width

### Validation Rules

#### 1. Basic Input Validation
```javascript
// All parameters must be positive numbers
const isValidPositiveNumber = (value) => {
  const num = parseFloat(value);
  return !isNaN(num) && num >= 0;
};

// Min values must be less than or equal to Max values
const isValidMinMax = (min, max) => {
  const minVal = parseFloat(min) || 0;
  const maxVal = parseFloat(max) || 0;
  return minVal <= maxVal;
};
```

#### 2. Mathematical Constraint Validation
The system prevents invalid configurations by checking:

**When Period is Locked:**
- Changing pulse width: Ensures `Period - Pulse Width ≥ 0` (no negative intervals)
- Changing interval: Ensures `Period - Interval ≥ 0` (no negative pulse widths)

**When Pulse Width is Locked:**
- Changing period: Ensures `Period - Pulse Width ≥ 0` (no negative intervals)

**When Interval is Locked:**
- Changing period: Ensures `Period - Interval ≥ 0` (no negative pulse widths)

#### 3. Real-time Calculation Examples

**Example 1: Period Locked**
```
Initial State:
- Period: Min = 120ms, Max = 540ms (locked)
- Pulse Width: Min = 100ms, Max = 400ms
- Interval: Min = 20ms, Max = 140ms

Action: Change Pulse Width Min to 50ms
Calculation: 
- New Interval Min = 120 - 50 = 70ms
- New Interval Max = 540 - 400 = 140ms
Result: Interval updates to Min = 70ms, Max = 140ms
```

**Example 2: Pulse Width Locked**
```
Initial State:
- Period: Min = 120ms, Max = 540ms
- Pulse Width: Min = 100ms, Max = 400ms (locked)
- Interval: Min = 20ms, Max = 140ms

Action: Change Period Min to 200ms
Calculation:
- New Interval Min = 200 - 100 = 100ms
- New Interval Max = 540 - 400 = 140ms
Result: Interval updates to Min = 100ms, Max = 140ms
```

**Example 3: Interval Locked**
```
Initial State:
- Period: Min = 120ms, Max = 540ms
- Pulse Width: Min = 100ms, Max = 400ms
- Interval: Min = 20ms, Max = 140ms (locked)

Action: Change Period Min to 150ms
Calculation:
- New Pulse Width Min = 150 - 20 = 130ms
- New Pulse Width Max = 540 - 140 = 400ms
Result: Pulse Width updates to Min = 130ms, Max = 400ms
```

### Average Calculation
All parameters automatically calculate their average values:
```javascript
const calculateAvg = (min, max) => {
  const minVal = parseFloat(min) || 0;
  const maxVal = parseFloat(max) || 0;
  return ((minVal + maxVal) / 2).toFixed(1);
};
```

### State Management Architecture
- **Main State**: Stores the actual validated parameter values
- **Local State**: Manages user input and display values
- **Synchronization**: Automatic sync between main and local states with validation
- **Validation Triggers**: Real-time validation on blur and Enter key press

### Validation Flow
1. **Input Validation**: Check if value is a positive number
2. **Range Validation**: Ensure min ≤ max for the parameter
3. **Constraint Validation**: Check mathematical relationships based on locked parameter
4. **State Update**: Update both main and local states if validation passes
5. **Recalculation**: Automatically recalculate dependent parameters
6. **UI Update**: Synchronize local state to reflect calculated values

### Implementation Requirements
- Always maintain the mathematical relationship `Period = Pulse Width + Interval`
- Ensure exactly one parameter is locked at all times
- Implement real-time validation on user input
- Update both main and local states when recalculating parameters
- Prevent invalid configurations that would result in negative values
- Provide immediate visual feedback for locked parameters
- Calculate and display average values automatically

### Waveform Definition Generation
- **Pulse Structure**: One pulse = one ON segment (pulse width) + one OFF segment (interval)
- **Waveform Structure**: Waveform consists of (pulse × pulse count) segments
- **Total Segments**: 2 × pulse count (each pulse has 2 segments)
- **Random Sampling**: Use Mersenne Twister uniform distribution for time span values
- **Pattern**: ON, OFF, ON, OFF, ... (repeating for each pulse)
- **Pulse Count Range**: 0-511 pulses (supports fractional values)
- **Fractional Pulses**: Generate partial pulses for non-integer pulse counts
- **Time Span Sampling**: Randomly sample from min/max ranges for each segment
- **Time Span Precision**: All values rounded to 2 decimal places

### Visual Waveform Display
- **SVG-based Display**: Real-time visualization of pulse train
- **Rising/Falling Edges**: Sharp vertical transitions between amplitude levels
- **Proportional Scaling**: Segment widths proportional to time spans
- **Amplitude Visualization**: Visual height corresponds to output percentage
- **Grid Background**: Reference grid for visual alignment
- **Consistent Rendering**: Display matches waveform definition table exactly

### Advanced Settings Implementation
- **Modal Access**: Gear icon (⚙️) opens Advanced Settings modal for each parameter
- **Step Size Control**: Individual step size settings for Period, Pulse Width, and Interval
- **Step Size Validation**: Only positive integers allowed (empty = no constraint)
- **Rounding Algorithm**: Round to nearest step size increment, then to 2 decimal places
- **Real-time Updates**: Waveform regenerates automatically when settings are applied
- **User Interface**: Clean modal with step size explanation and parameter-specific inputs
